Benjamin Han
cs61c-mm
hw1

1a: 1. servers
    2. petabyte
    3. supercomputers
    4. virtual worlds
    5. CPU
    6. RAM
    7. low-end servers
    8. multi-core processors
    9. datacenters
    10. embedded computers
    11. compiler
    12. VHDL
    13. desktop computers
    14. assembler
    15. fortran
    16. instruction
    17. machine language
    18. cobol
    19. assembly language
    20. operating system
    21. application software
    22. system software
    23. C
    24. high-level language
    25. terabyte
    26. bit
1b: 1kb / (1 Gb/s) = 8 * 10^-6 = 8 us
1c: 2 us from Cache = 20 us from DRAM
      	     	    = 2,000,000 us from disk
 		    = 2,000 us from flash
1d: Five nines = 99.999%
    (1 - Five nines) * 1 year = 5.256 minutes
1e: At warehouse scale, thousands of computers operating nearly flawlessly will still fail on an hourly basis. WSC should be fault-tolerant to handle these losses.
1f: Desktop grade hardware is significantly cheaper than servers. At the cost of cheap hardware, desktop-grade is much more likely to fail, so Google must capably handle these losses.

2a: MapReduce uses a divide and conquer approach, but is not useful when iteration is necessary. Examples of iteration are matrix multiplication or molecular structural relaxation.
2b: Key = word as string; value = integer number of appearances in document
    void map(String file, String contents) {
        for (String word : contents) {
            //increment wordCount of word by 1, or set to 1 if nonexistant
        }
    }
    //shuffle wordCounts to difference machines
    int reduce(String word, List<integer> wordCounts) {
        int totalCount = 0;
	for (int partialCount : wordCounts) {
	    totalCount += count;
	}
	return totalCount;
    }
2c: key = article-name; value =  outgoing-link
    void map (article s, int n) {
        for (article linked : //set of outgoing links) {
	   //add linked to set of articles
	   if (set does not contain linked) {
	       map(linked, n - 1);
	   }
        }
    }
    //shuffle sorted list of articles
    set<articles> reduce(list<set<articles>> partialList) {
        for (set<articles> partialSet : partialList) {
	    //aggregate partialSets
	}
	return //completeSet
    }
